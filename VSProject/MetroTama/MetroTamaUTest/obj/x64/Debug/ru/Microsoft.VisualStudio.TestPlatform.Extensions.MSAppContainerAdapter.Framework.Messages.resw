<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UTA_AssemblyCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Не удалось применить метод очистки сборки {0}.{1}. Сообщение об ошибке: {2}. StackTrace: {3}</value>
  </data>
  <data name="Common_CannotBeNullOrEmpty" xml:space="preserve">
    <value>Этот параметр не должен быть пустым или иметь значение null.</value>
  </data>
  <data name="UTA_TestInitializeAndCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть нестатическим и открытым, не должен возвращать значение и не должен принимать параметры. Кроме того, при использовании в методе async-await возвращаемое значение должно иметь тип Task.</value>
  </data>
  <data name="UTA_ClassOrAssemblyInitializeMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть статическим и открытым, не должен возвращать значение и должен принимать один параметр, имеющий тип TestContext. Кроме того, при использовании в методе async-await возвращаемое значение должно иметь тип Task.</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyInit" xml:space="preserve">
    <value>UTA013: {0}: невозможно определить более одного метода в сборке с помощью атрибута AssemblyInitialize.</value>
  </data>
  <data name="UTA_ErrorMultiClassInit" xml:space="preserve">
    <value>UTA025: {0}: невозможно определить более одного метода в классе с помощью атрибута ClassInitialize.</value>
  </data>
  <data name="UTA_ErrorPredefinedTestProperty" xml:space="preserve">
    <value>UTA023: {0}: не удается определить предопределенное свойство {2} в методе {1}.</value>
  </data>
  <data name="UTA_InitMethodThrows" xml:space="preserve">
    <value>Методом инициализации {0}.{1} создано исключение. {2}: {3}.</value>
  </data>
  <data name="TestNotFound" xml:space="preserve">
    <value>Метод теста {0} не найден.</value>
  </data>
  <data name="Execution_Test_Timeout" xml:space="preserve">
    <value>Превышено время ожидания выполнения теста "{0}".</value>
  </data>
  <data name="UTA_ErrorMultiInit" xml:space="preserve">
    <value>UTA018: {0}: невозможно определить более одного метода с помощью атрибута TestInitialize.</value>
  </data>
  <data name="UTA_ErrorNonPublicTestClass" xml:space="preserve">
    <value>UTA001: атрибут TestClass определен в классе {0}, не являющемся общим</value>
  </data>
  <data name="UTA_ErrorIncorrectTestMethodSignature" xml:space="preserve">
    <value>UTA007: Метод {1}, определенный в классе {0}, не имеет правильную сигнатуру. Метод теста, помеченный атрибутом [TestMethod], должен быть нестатическим, открытым и иметь тип возвращаемого значения void; также он не должен принимать параметры. Пример: public void Test.Class1.Test(). Кроме того, если вы используете модификаторы async-await в методе теста, тип возвращаемого значения должен быть Task. Пример: public async Task Test.Class1.Test2()</value>
  </data>
  <data name="UTA_ErrorTestPropertyNullOrEmpty" xml:space="preserve">
    <value>UTA021: {0}: в методе {1} определено пользовательское свойство, имя которого имеет значение NULL или пусто. Пользовательское свойство должно иметь допустимое имя.</value>
  </data>
  <data name="UTA_NoTestResult" xml:space="preserve">
    <value>Ошибка при выполнении теста. Расширение не возвратило результаты. Если используется расширение атрибута TestMethodAttribute, обратитесь к поставщику.</value>
  </data>
  <data name="UTA_ClassCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Не удалось применить метод очистки класса {0}.{1}. Сообщение об ошибке: {2}. Трассировка стека: {3}</value>
  </data>
  <data name="UTA_ErrorTestPropertyAlreadyDefined" xml:space="preserve">
    <value>UTA022: {0}.{1}: пользовательское свойство "{2}" уже определено. В качестве значения используется "{3}".</value>
  </data>
  <data name="UTA_ClassInitMethodThrows" xml:space="preserve">
    <value>Методом инициализации класса {0}.{1} создано исключение. {2}: {3}.</value>
  </data>
  <data name="UTA_ExecuteThrewException" xml:space="preserve">
    <value>При выполнении теста возникло исключение. Если используется расширение атрибута TestMethodAttribute, обратитесь к поставщику. Сообщение об ошибке: {0}</value>
  </data>
  <data name="UTA_TestMethodThrows" xml:space="preserve">
    <value>Метод проверки {0}.{1} выдал исключение: {2}.</value>
  </data>
  <data name="UTA_CleanupMethodThrows" xml:space="preserve">
    <value>Методом TestCleanup {0}.{1} создано исключение. {2}: {3}.</value>
  </data>
  <data name="UTA_InstanceCreationError" xml:space="preserve">
    <value>Не удается создать экземпляр класса {0}. Ошибка: {1}.</value>
  </data>
  <data name="UTA_TestContextTypeMismatchLoadError" xml:space="preserve">
    <value>Для свойства {0}.TestContext указан неправильный тип.</value>
  </data>
  <data name="UTA_ClassOrAssemblyCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Метод {0}.{1} имеет неправильную сигнатуру. Метод должен быть статическим и открытым, не должен возвращать значение и не должен принимать параметры. Кроме того, при использовании в методе async-await возвращаемое значение должно иметь тип Task.</value>
  </data>
  <data name="UTA_ErrorGenericTestMethod" xml:space="preserve">
    <value>UTA015: универсальный метод не может быть методом теста. {0}.{1} имеет недопустимую подпись</value>
  </data>
  <data name="UTA_AssemblyInitMethodThrows" xml:space="preserve">
    <value>Методом инициализации сборки {0}.{1} создано исключение. {2}: {3}. Выполнение теста прекращается.</value>
  </data>
  <data name="UTA_ErrorMultiClean" xml:space="preserve">
    <value>UTA024: {0}: невозможно определить более одного метода с помощью атрибута TestCleanup.</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Не удалось получить сообщение для исключения с типом "{0}" в связи с возникновением исключения.)</value>
  </data>
  <data name="CouldNotInspectTypeDuringDiscovery" xml:space="preserve">
    <value>Средству MSTestAdapter не удалось обнаружить тесты в классе "{0}" сборки "{1}". Причина: {2}.</value>
  </data>
  <data name="UTA_TestContextSetError" xml:space="preserve">
    <value>Не удается задать свойство TestContext для класса {0}. Ошибка: {1}.</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyClean" xml:space="preserve">
    <value>UTA014: {0}: невозможно определить более одного метода в сборке с помощью атрибута AssemblyCleanup.</value>
  </data>
  <data name="UTA_FailedToGetTestMethodException" xml:space="preserve">
    <value>Не удалось получить исключение, вызванное методом тестирования {0}.{1}.</value>
  </data>
  <data name="UTA_EndOfInnerExceptionTrace" xml:space="preserve">
    <value> --- Конец трассировки стека внутреннего исключения ---</value>
  </data>
  <data name="UTA_ErrorInvalidTimeout" xml:space="preserve">
    <value>UTA054: {0}.{1} имеет недопустимый атрибут Timeout. Время ожидания должно быть допустимым целым числом и не может быть меньше 0.</value>
  </data>
  <data name="Common_MustBeGreaterThanZero" xml:space="preserve">
    <value>Этот параметр должен быть больше нуля.</value>
  </data>
  <data name="ExecuteInClassicModeFails" xml:space="preserve">
    <value>Невозможно запускать модульные тесты приложений для Магазина Windows за пределами appcontainer. Создайте пакет приложения и запустите тесты в режиме appcontainer.</value>
  </data>
  <data name="UTA_NoDefaultConstructor" xml:space="preserve">
    <value>Не удается получить конструктор по умолчанию для класса {0}.</value>
  </data>
  <data name="UTA_TestContextLoadError" xml:space="preserve">
    <value>Не удается найти свойство {0}.TestContext. Ошибка: {1}.</value>
  </data>
  <data name="EnumeratorLoadTypeErrorFormat" xml:space="preserve">
    <value>{0}: {1}</value>
  </data>
  <data name="UTA_ErrorInValidTestContextSignature" xml:space="preserve">
    <value>UTA031: в классе {0} отсутствует допустимое свойство TestContext. Свойство TestContext должно иметь тип TestContext, быть нестатическим, общим и не должно быть предназначено только для чтения. Например: public TestContext TestContext.</value>
  </data>
  <data name="UTA_CleanupMethodThrowsGeneralError" xml:space="preserve">
    <value>Ошибка вызова метода очистки теста для класса тестирования {0}: {1}</value>
  </data>
  <data name="UTA_MethodDoesNotExists" xml:space="preserve">
    <value>Метод {0}.{1} не существует.</value>
  </data>
  <data name="TestAssembly_FileDoesNotExist" xml:space="preserve">
    <value>Файл не существует: {0}</value>
  </data>
  <data name="UTA_CleanupStackTrace" xml:space="preserve">
    <value>Трассировка стека TestCleanup</value>
  </data>
  <data name="UTA_TypeLoadError" xml:space="preserve">
    <value>Не удается получить тип {0}. Ошибка: {1}.</value>
  </data>
  <data name="TypeLoadFailed" xml:space="preserve">
    <value>Не удается загрузить типы из тестового источника "{0}". В этом источнике невозможно обнаружить один или несколько тестов.</value>
  </data>
  <data name="UTA_ErrorMultiClassClean" xml:space="preserve">
    <value>UTA026: {0}: невозможно определить более одного метода в классе с помощью атрибута ClassCleanup.</value>
  </data>
</root>