<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ElementNumbersDontMatch" xml:space="preserve">
    <value>Число элементов в наборе не соответствует ожидаемому. Ожидается: &lt;{1}&gt;. Фактически: &lt;{2}&gt;.{0}</value>
  </data>
  <data name="IsMatchFail" xml:space="preserve">
    <value>Строка "{0}" не соответствует шаблону "{1}". {2}.</value>
  </data>
  <data name="IsInstanceOfFailMsg" xml:space="preserve">
    <value>{0}Ожидается тип: &lt;{1}&gt;. Фактический тип: &lt;{2}&gt;.</value>
  </data>
  <data name="ContainsFail" xml:space="preserve">
    <value>Строка "{0}" не содержит строку "{1}". {2}.</value>
  </data>
  <data name="InternalObjectNotValid" xml:space="preserve">
    <value>Внутренний объект, на который дана ссылка, больше не является допустимым.</value>
  </data>
  <data name="StartsWithFail" xml:space="preserve">
    <value>Строка "{0}" не начинается строкой "{1}". {2}.</value>
  </data>
  <data name="AreEqualDifferentTypesFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1} ({2})&gt;. Фактически: &lt;{3} ({4})&gt;. {0}</value>
  </data>
  <data name="BothSameElements" xml:space="preserve">
    <value>Наборы содержат одинаковые элементы. {0}</value>
  </data>
  <data name="InvalidParameterToAssert" xml:space="preserve">
    <value>Параметр "{0}" не является допустимым. {1}.</value>
  </data>
  <data name="AreNotEqualDeltaFailMsg" xml:space="preserve">
    <value>Между ожидаемым значением &lt;{1}&gt; и фактическим значением &lt;{2}&gt; требуется разница более чем &lt;{3}&gt;. {0}</value>
  </data>
  <data name="ElementsAtIndexDontMatch" xml:space="preserve">
    <value>Элемент по индексу {0} не соответствует.</value>
  </data>
  <data name="BothCollectionsSameReference" xml:space="preserve">
    <value>Ссылки в обоих наборах указывают на один и тот же объект набора. {0}</value>
  </data>
  <data name="PrivateAccessorConstructorNotFound" xml:space="preserve">
    <value>
      Не удается найти конструктор с указанной подписью. Возможно, требуется создать заново закрытый 
      метод доступа, либо член является закрытым и определенным на основе базового класса. Если 
      справедливо последнее, то необходимо передать тип, определяющий член, в конструктор для PrivateObject.
    </value>
  </data>
  <data name="AssertionFailed" xml:space="preserve">
    <value>Ошибка в {0}. {1}</value>
  </data>
  <data name="DoNotUseAssertEquals" xml:space="preserve">
    <value>&amp;Нельзя использовать Assert.Equals для Assertions. Вместо этого используйте Assert.AreEqual и перегрузки.</value>
  </data>
  <data name="UTF_TestMethodNoExceptionDefault" xml:space="preserve">
    <value>Метод теста {0}.{1} не выдал исключение. В атрибуте {2}, определенном для метода тестирования, ожидалось исключение.</value>
  </data>
  <data name="Common_NullInMessages" xml:space="preserve">
    <value>(NULL)</value>
  </data>
  <data name="UTF_TestMethodWrongExceptionDerivedAllowed" xml:space="preserve">
    <value>Метод теста {0}.{1} выдал исключение {2} вместо ожидаемого исключения {3} или производного от него типа. Сообщение исключения: {4}</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch2" xml:space="preserve">
    <value>Элемент по индексу {1} имеет значение (null). Ожидаемый тип: &lt;{2}&gt;.{0}</value>
  </data>
  <data name="NoExceptionThrown" xml:space="preserve">
    <value>Исключение не создано. Ожидалось исключение {1}. {0}</value>
  </data>
  <data name="CollectionEqualReason" xml:space="preserve">
    <value>{0}({1})</value>
  </data>
  <data name="EqualsTesterInvalidArgs" xml:space="preserve">
    <value>Недопустимый аргумент - EqualsTester не может использовать значение NULL.</value>
  </data>
  <data name="AccessStringInvalidSyntax" xml:space="preserve">
    <value>Строка доступа имеет недопустимый синтаксис.</value>
  </data>
  <data name="ElementTypesAtIndexDontMatch" xml:space="preserve">
    <value>Тип элемента по индексу {1} не соответствует ожидаемому. Ожидаемый тип: &lt;{2}&gt;. Фактический тип: &lt;{3}&gt;.{0}</value>
  </data>
  <data name="ErrorInvalidCast" xml:space="preserve">
    <value>Невозможно преобразовать объект типа {0} к {1}.</value>
  </data>
  <data name="AreNotEqualFailMsg" xml:space="preserve">
    <value>Ожидается любое значение, кроме: &lt;{1}&gt;. Фактически: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="UTF_TestMethodNoException" xml:space="preserve">
    <value>Метод теста {0}.{1} не выдал ожидаемое исключение {2}. {3}</value>
  </data>
  <data name="IsNotMatchFail" xml:space="preserve">
    <value>Строка "{0}" соответствует шаблону "{1}". {2}.</value>
  </data>
  <data name="UTF_TestMethodWrongException" xml:space="preserve">
    <value>Метод теста {0}.{1} выдал исключение {2} вместо ожидаемого исключения {3}. Сообщение исключения: {4}</value>
  </data>
  <data name="WrongExceptionThrown" xml:space="preserve">
    <value>Создано исключение {2}, хотя ожидалось исключение {1}. {0}
Сообщение исключения: {3}
Трассировка стека: {4}</value>
  </data>
  <data name="IsNotInstanceOfFailMsg" xml:space="preserve">
    <value>Неверный тип: &lt;{1}&gt;. Фактический тип: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="AreEqualDeltaFailMsg" xml:space="preserve">
    <value>Между ожидаемым значением &lt;{1}&gt; и фактическим значением &lt;{2}&gt; требуется разница не более чем &lt;{3}&gt;. {0}</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(Не удалось получить сообщение для исключения с типом "{0}" в связи с возникновением исключения.)</value>
  </data>
  <data name="AllItemsAreUniqueFailMsg" xml:space="preserve">
    <value>Обнаружен совпадающий элемент: &lt;{1}&gt;. {0}</value>
  </data>
  <data name="Common_ObjectString" xml:space="preserve">
    <value>(объект)</value>
  </data>
  <data name="EndsWithFail" xml:space="preserve">
    <value>Строка "{0}" не оканчивается строкой "{1}". {2}.</value>
  </data>
  <data name="NumberOfElementsDiff" xml:space="preserve">
    <value>Разное число элементов.</value>
  </data>
  <data name="NullParameterToAssert" xml:space="preserve">
    <value>Параметр "{0}" не является допустимым. Значение не может быть NULL. {1}.</value>
  </data>
  <data name="BothCollectionsSameElements" xml:space="preserve">
    <value>Наборы содержат одинаковые элементы.</value>
  </data>
  <data name="BothCollectionsEmpty" xml:space="preserve">
    <value>Оба набора пусты. {0}</value>
  </data>
  <data name="AreEqualCaseFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1}&gt;. Отличается на фактическое значение: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Свойство {0} имеет тип {1}. Ожидается тип {2}.</value>
  </data>
  <data name="AreSameGivenValues" xml:space="preserve">
    <value>Не передавайте типы значений в функцию AreSame(). Значения, преобразованные к Object, никогда не будут одинаковыми. Попробуйте использовать AreEqual(). {0}</value>
  </data>
  <data name="UTF_ExpectedExceptionTypeMustDeriveFromException" xml:space="preserve">
    <value>Тип ожидаемого исключения должен быть System.Exception или производным от System.Exception.</value>
  </data>
  <data name="AreEqualFailMsg" xml:space="preserve">
    <value>Ожидается: &lt;{1}&gt;. Фактически: &lt;{2}&gt;. {0}</value>
  </data>
  <data name="ActualHasMismatchedElements" xml:space="preserve">
    <value>Ожидаемый набор содержит следующее число событий &lt;{2}&gt;: {1}. Фактический набор содержит число событий: {3}. {0}</value>
  </data>
  <data name="PrivateAccessorMemberNotFound" xml:space="preserve">
    <value>
      Не удается найти указанный член ({0}). Возможно, требуется создать заново закрытый метод доступа
      либо член является закрытым и определенным на основе базового класса. Если справедливо последнее, то 
      необходимо передать тип, определяющий член, в конструктор для PrivateObject.
    </value>
  </data>
</root>